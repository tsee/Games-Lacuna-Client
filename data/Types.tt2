###################################################
#
# This is a generated file DO NOT EDIT
# generated by [% generator %] using [% template_name %]
#
###################################################
#
# Any structural changes should be made to [% template_name %]
#
# Any informational changes should be made to one of:
#
[% FOREACH file IN data_files -%]
#     [% file %]
[% END -%]
#
# All changes should be followed by running:
#     [% sort_program %]
#     [% generator %]
#
###################################################
[%
    is_functions = [];
    resource_lists = [];
    FOREACH resource;
        resource_lists.push("${key}_types");
        is_functions.push("is_${key}_type");
    END;
    lists = [
        'ship_types',
        'ship_attribute_types',
    ];
    FOREACH list;
        lists.push("${key}_types");
    END;
    tag_functions = ['get_tags','tag_list'];
    meta_functions = [
        'meta_building_list',
        'meta_type',
        'meta_type_list',
        'building_label',
        'building_type_from_label'
    ];
    list_functions = [];
    CALL list_functions.import(
        resource_lists,
        lists,
    );
    ship_functions = [
        'ship_types',
        'ship_attribute_types',
        'ship_tags_list',
        'ship_tags',
        'ship_type_human',
    ];
    functions = [];
    CALL functions.import(
        resource_lists,
        lists,
        tag_functions,
        meta_functions,
        ship_functions,
        is_functions,
    );
%]
package [% package %];

use strict;
use warnings;
use List::MoreUtils qw(any);

require Exporter;

our @ISA = qw(Exporter);
our @EXPORT = qw( [% functions.unique.join(' ') %] );
our %EXPORT_TAGS = (
    list     => [qw( [% list_functions.unique.join(' ') %] )],
    resource => [qw( [% resource_lists.unique.join(' ') %] )],
    tag      => [qw( [%  tag_functions.unique.join(' ') %] )],
    meta     => [qw( [% meta_functions.unique.join(' ') %] )],
    ship     => [qw( [% ship_functions.unique.join(' ') %] )],
    is       => [qw( [%   is_functions.unique.join(' ') %] )],
    all      => [@EXPORT],
);
[% FOREACH resource %]
{
    my @[% key %] = qw( [% value.join(' ') %] );
    sub [% key %]_types {
        return @[% key %];
    }
    sub is_[% key %]_type {
        my( $check ) = @_;
        return any { $check eq $_ } @[% key %];
    }
}
[% END %]
[% FOREACH list %]
{
    my @[% key %] = qw( [% value.join(' ') %] );
    sub [% key %]_types {
        return @[% key %];
    }
}
[% END %]

{
    my %meta_types = (
        [%~ FOREACH building_type IN building_meta.keys.sort %]
        [% building_type %] => [qw(
            [%~ FOREACH building IN building_meta.$building_type.sort %]
            [% building ; END %]
        )],
        [%~ END %]
    );

    sub meta_type {
        my( $building ) = @_;
        return unless $building;
        for my $k ( keys %meta_types ){
            if( any {$_ eq $building} @{$meta_types{$k}} ){
                return $k;
            }
        }
        return;
    }
    sub meta_type_list{
        return keys %meta_types if wantarray;
        return [keys %meta_types];
    }
    sub meta_building_list {
        my( $type ) = @_;
        return unless $type;
        my $buildings = $meta_types{$type};
        return @$buildings if wantarray;
        return [@$buildings];
    }
}
{
    my @tags = qw([% building_data.tag_list.join(' ') %]);
    sub tag_list {
        return @tags;
    }
}
{
    my %tags = (
    [%- FOREACH building_data.tags %]
        [% key %] => [qw([% value.join(' ') %])],
    [%- END %]
    );
    sub get_tags{
        my( $building ) = @_;
        return @{ $tags{$building} };
    }
}
{
    my %label = (
    [%- FOREACH building_data.labels %]
        [% key %] => "[% value %]",
    [%- END %]
    );

    sub building_label{
        my( $building ) = @_;
        return $label{$building};
    }

    my %type_from_label =
        map {
            my $name = lc $label{$_};
            $name =~ s/[^\w]//g;
            $name => $_
        } keys %label;

    sub building_type_from_label {
        my( $name ) = @_;
        return unless defined $name;
        $name = lc $name;
        $name =~ s/[^\w]//g;
        return $type_from_label{$name};
    }
}
{
    my %ships = (
        [%~ FOREACH pair IN ship.pairs %]
        [% pair.key %] => {
            type_human => '[% pair.value.type_human %]',
            tags       => [
            [%~ FOREACH tag IN pair.value.tags %]
                '[% tag %]',
            [%~ END %]
            ],
        },
        [%~ END %]
    );
[%~
    ship_tags = [];
    FOREACH value IN ship.values;
        FOREACH tag IN value.tags;
            ship_tags.push( tag );
        END;
    END;
%]

    sub ship_types {
        return keys %ships;
    }
    sub ship_tags_list {
        my @tags = qw( [% ship_tags.unique.sort.join(" ") %] );
        return wantarray ? @tags : [@tags];
    }
    sub ship_tags {
        my( $type ) = @_;
        return unless $type;
        my $tags = $ships{$type}{tags};
        return wantarray ? @$tags : [@$tags];
    }
    sub ship_type_human {
        my( $type ) = @_;
        return unless $type;
        return $ships{$type}{type_human};
    }
}
1;

__END__

=head1 NAME

[% package %]

=head1 SYNOPSIS

    use [% package %];

=head1 FUNCTIONS

=over 4
[% FOREACH function IN functions %]
=item [% function %]
[% END %]
=back

=cut
